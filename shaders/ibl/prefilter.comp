#version 460 core
// clang-format off

{% include "consts.glsl" %}
{% include "brdf.glsl" %}
{% include "ibl/cubemap_to_xyz.glsl" %}
{% include "ibl/brdf_sampling.glsl" %}

layout(local_size_x = {{ ibl.local_size_xy }}, local_size_y = {{ ibl.local_size_xy }}
    , local_size_z = {{ ibl.local_size_z }}) in;

layout(binding = 0) uniform samplerCube cubemap;
layout(rgba32f, binding = 1) uniform writeonly imageCube prefilterMap;

uniform float linearRoughness;

void main()
{
    uvec3 globalId = gl_GlobalInvocationID.xyz;
    vec3 normal = directionFromCubemapUv(globalId, imageSize(prefilterMap).x);

    vec3 n = normalize(normal);
    // make the simplyfying assumption that V equals R equals the normal
    vec3 v = n;

    const uint SAMPLE_COUNT = 1024u;
    vec3 prefilteredColor = vec3(0.0);
    float totalWeight = 0.0;

    float roughness = linearRoughness * linearRoughness;

    for (uint i = 0u; i < SAMPLE_COUNT; ++i) {
        // generates a sample vector that's biased towards the preferred alignment
        // direction (importance sampling).
        vec2 Xi = hammersley(i, SAMPLE_COUNT);
        vec3 h = importanceSampleGgx(Xi, n, roughness);
        vec3 l = normalize(2.0 * dot(v, h) * h - v);

        float NoL = max(dot(n, l), 0.0);

        if (NoL > 0.0) {
            float NoH = max(dot(n, h), 0.0);
            float HoV = max(dot(h, v), 0.0);

            float D = distributionGgx(NoH, roughness);

            float pdf = D * NoH / ((4.0 * HoV) + 0.0001);

            // clang-format off
            const float resolution = float({{ ibl.cubemap_size }});
            const float roughness_levels = float({{ ibl.prefilter_map_roughnes_levels - 1 }});
            // clang-format on

            float saTexel = 4.0 * PI / (roughness_levels * resolution * resolution);
            float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);
            // sample from the environment's mip level based on roughness/pdf
            float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel);

            prefilteredColor += textureLod(cubemap, l, mipLevel).rgb * NoL;
            totalWeight += NoL;
        }
    }

    prefilteredColor = prefilteredColor / totalWeight;
    imageStore(prefilterMap, ivec3(globalId), vec4(prefilteredColor, 0.0));
}
