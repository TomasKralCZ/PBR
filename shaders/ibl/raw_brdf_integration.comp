#version 460 core

//#defines

// {% include "consts.glsl" %}
// {% include "ibl/cubemap_to_xyz.glsl" %}
// {% include "structs/brdf_bufs.glsl" %}

#ifdef MERL_BRDF
// {% include "measured_brdf/brdf_merl.glsl" %}
#endif

#ifdef MIT_BRDF
// {% include "measured_brdf/brdf_mit.glsl" %}
#endif

#ifdef UTIA_BRDF
// {% include "measured_brdf/brdf_utia.glsl" %}
#endif

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0) uniform samplerCube cubemap;
layout(rgba32f, binding = 1) uniform writeonly imageCube rawBrdfMap;

void main()
{
    uvec3 globalId = gl_GlobalInvocationID.xyz;
    vec3 normal = directionFromCubemapUv(globalId, imageSize(rawBrdfMap).x);

    // Create basis vectors
    vec3 up = vec3(0.0, 1.0, 0.0);
    vec3 right = normalize(cross(up, normal));
    up = normalize(cross(normal, right));

    vec3 irradiance = vec3(0.0);

    float sampleDelta = 0.025;
    float sampleCount = 0.0;

    for (float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta) {
        for (float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta) {
            // Spherical coordinates to cartesian
            vec3 baseSampleDir = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
            // Tangent space to world space (need world coords to fetch from cubemap)
            vec3 sampleDir = baseSampleDir.x * right + baseSampleDir.y * up + baseSampleDir.z * normal;

            // cos(theta) is the same as dot(normal, lightDir)
            // For the sin(theta) term, see
            // https://cglearn.eu/pub/advanced-computer-graphics/physically-based-shading - Energy
            // Conservation in Lambert. Basically sin(theta) scales the light proportionally to the size of
            // the "ring" on the hemisphere. It makes sense when you think about it as an integral...
            // (continuous, not discrete).
            vec3 radiance = texture(cubemap, sampleDir).rgb * cos(theta) * sin(theta);

            // "light direction" = sampleDir,
            // Restriction - viewDir = normal, same as other techniques...
            // tangent = right
            // bitangenmt = up

#ifdef MERL_BRDF
            vec3 brdf = lookup_brdf_merl(sampleDir, normal, normal, right, up);
#endif

#ifdef MIT_BRDF
            vec3 brdf = lookup_brdf_mit(sampleDir, normal, normal, right, up);
#endif

#ifdef UTIA_BRDF
            vec3 brdf = lookup_brdf_utia(sampleDir, normal, normal, right, up);
#endif

            irradiance += brdf * radiance;
            sampleCount++;
        }
    }

    // FIXME: light is weak, why need to multiply ?
    // FIXME(high): check if any BRDF values are negative, that could screw up the integration
    vec4 color = vec4(PI * irradiance / float(sampleCount), 1.0);
    imageStore(rawBrdfMap, ivec3(globalId), color);
}
