#version 460 core
// clang-format off
//#defines

{% include "consts.glsl" %}
{% include "ibl/cubemap_to_xyz.glsl" %}
{% include "ibl/brdf_sampling.glsl" %}
{% include "structs/brdf_bufs.glsl" %}

#ifdef MERL_BRDF
{% include "measured_brdf/brdf_merl.glsl" %}
#endif

#ifdef MIT_BRDF
{% include "measured_brdf/brdf_mit.glsl" %}
#endif

#ifdef UTIA_BRDF
{% include "measured_brdf/brdf_utia.glsl" %}
#endif

layout(local_size_x = {{ ibl.local_size_xy }}, local_size_y = {{ ibl.local_size_xy }}
    ,local_size_z = {{ ibl.local_size_z }}) in;
// clang-format on

layout(binding = 0) uniform samplerCube cubemap;
layout(rgba32f, binding = 1) uniform writeonly imageCube rawBrdfMap;

void main()
{
    uvec3 globalId = gl_GlobalInvocationID.xyz;
    vec3 normal = directionFromCubemapUv(globalId, imageSize(rawBrdfMap).x);

    // Create basis vectors
    vec3 up = vec3(0.0, 1.0, 0.0);
    vec3 right = normalize(cross(up, normal));
    up = normalize(cross(normal, right));

    vec3 irradiance = vec3(0.0);

    const uint SAMPLE_COUNT = 4096;
    for (uint i = 0; i < SAMPLE_COUNT; i++) {
        // http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
        vec2 hammersleyPoint = hammersley(i, SAMPLE_COUNT);
        float theta = acos(sqrt(1. - hammersleyPoint.x));
        float phi = 2 * PI * hammersleyPoint.y;

        // Spherical coordinates to cartesian
        vec3 baseSampleDir = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
        // Change of basis from canonical to the basis of the normal
        vec3 sampleDir = baseSampleDir.x * right + baseSampleDir.y * up + baseSampleDir.z * normal;

        // cos(theta) is Lambert's law
        // sin(theta) arises due to how integrating over the hemisphere works
        vec3 radiance = texture(cubemap, sampleDir).rgb * cos(theta) * sin(theta);

        // "light direction" = sampleDir,
        // Restriction - viewDir = normal, same as other techniques...
        // tangent = right
        // bitangent = up
        sampleDir = normalize(sampleDir);

#ifdef MERL_BRDF
        vec3 brdf = lookup_brdf_merl(sampleDir, normal, normal, right, up);
        float normalizer = 16.;
#endif

#ifdef MIT_BRDF
        vec3 brdf = lookup_brdf_mit(sampleDir, normal, normal, right, up);
        float normalizer = 1.0;
#endif

// FIXME(high): analytic light source works, IBL does not
#ifdef UTIA_BRDF
        vec3 brdf = lookup_brdf_utia(sampleDir, normalize(normal - vec3(0.1)), normal, right, up);
        float normalizer = 1.;
#endif

        irradiance += brdf * radiance * normalizer;
    }

    // FIXME(high): check if any BRDF values are negative, that could screw up the integration
    // FIXME(high): I'm pretty sure some of the UTIA values are negative
    vec4 color = vec4(irradiance / float(SAMPLE_COUNT), 1.0);
    imageStore(rawBrdfMap, ivec3(globalId), color);
}
