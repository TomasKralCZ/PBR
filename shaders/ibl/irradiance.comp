#version 460 core
// clang-format off
{% include "consts.glsl" %}
{% include "ibl/cubemap_to_xyz.glsl" %}

layout(local_size_x = {{ ibl.local_size_xy }}, local_size_y = {{ ibl.local_size_xy }}
    , local_size_z = {{ ibl.local_size_z }}) in;
// clang-format on

layout(binding = 0) uniform samplerCube cubemap;
layout(rgba32f, binding = 1) uniform writeonly imageCube irradianceMap;

void main()
{
    uvec3 globalId = gl_GlobalInvocationID.xyz;
    vec3 normal = directionFromCubemapUv(globalId, imageSize(irradianceMap).x);

    // Create basis vectors
    vec3 up = vec3(0., 1.0, 0.);
    vec3 right = normalize(cross(up, normal));
    up = normalize(cross(normal, right));

    vec3 irradiance = vec3(0.);

    float sampleDelta = 0.025;
    int sampleCount = 0;

    for (float phi = 0.; phi < 2. * PI; phi += sampleDelta) {
        for (float theta = 0.; theta < 0.5 * PI; theta += sampleDelta) {
            // Spherical coordinates to cartesian
            vec3 baseSampleDir = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
            // Change of basis from canonical to the basis of the normal
            vec3 sampleDir = baseSampleDir.x * right + baseSampleDir.y * up + baseSampleDir.z * normal;

            // cos(theta) is Lambert's law
            // sin(theta) arises due to how integrating over the hemisphere works
            irradiance += texture(cubemap, sampleDir).rgb * cos(theta) * sin(theta);
            sampleCount++;
        }
    }

    vec4 color = vec4(PI * irradiance / float(sampleCount), 1.);
    imageStore(irradianceMap, ivec3(globalId), color);
}
