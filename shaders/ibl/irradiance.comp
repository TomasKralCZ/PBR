#version 460 core

//#import shaders/consts.glsl
//#import shaders/ibl/cubemap_to_xyz.glsl

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0) uniform samplerCube cubemap;
layout(rgba32f, binding = 1) uniform writeonly imageCube irradianceMap;

void main()
{
    uvec3 globalId = gl_GlobalInvocationID.xyz;
    vec3 normal = directionFromCubemapUv(globalId, imageSize(irradianceMap).x);

    // Create basis vectors
    vec3 up = vec3(0.0, 1.0, 0.0);
    vec3 right = normalize(cross(up, normal));
    up = normalize(cross(normal, right));

    vec3 irradiance = vec3(0.0);

    float sampleDelta = 0.025;
    float sampleCount = 0.0;

    for (float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta) {
        for (float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta) {
            // Spherical coordinates to cartesian
            vec3 tangentSampleDir = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
            // Tangent space to world space (need world coords to fetch from cubemap)
            vec3 sampleDir = tangentSampleDir.x * right + tangentSampleDir.y * up + tangentSampleDir.z * normal;

            // cos(theta) is the same as dot(normal, lightDir)
            // For the sin(theta) term, see
            // https://cglearn.eu/pub/advanced-computer-graphics/physically-based-shading - Energy Conservation in Lambert
            // Basically sin(theta) scales the light proportionally to the size of the "ring" on the hemisphere.
            // It makes sense when you think about it as an integral... (continuous, not discrete).
            irradiance += texture(cubemap, sampleDir).rgb * cos(theta) * sin(theta);
            sampleCount++;
        }
    }

    vec4 color = vec4(PI * irradiance / float(sampleCount), 1.0);
    imageStore(irradianceMap, ivec3(globalId), color);
}
